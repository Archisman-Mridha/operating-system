use core::arch::asm;

enum BitMasks {
  MSTATUS_MPP_CLEARER_MASK = 3 << 11,
  MSTATUS_MPP_SUPERVISOR = 1 << 11,

  SUPERVISOR_SOFTWARE_INTERRUPS_ENABLE_MASK = 1 << 1,
  SUPERVISOR_TIMER_INTERRUPTS_ENABLE_MASK = 1 << 5,
  SUPERVISOR_EXTERNAL_INTERRUPTS_ENABLE_MASK = 1 << 9,
}

// The mstatus (Machine Status) register keeps track of and controls the hart's current operating
// state.
// REFER : section 3.1.6 in privileged ISA manual.
pub struct Mstatus;

impl Mstatus {
  // NOTE : xPP (x = current privilege mode) bits represent the previous privilege mode.

  // Clears the MPP bits.
  #[inline]
  unsafe fn clearMppBits(&self) {
    asm!("csrc mstatus, {}", in(reg)BitMasks::MSTATUS_MPP_CLEARER_MASK as usize);
  }

  // Before switching to S-mode, we'll set the MPP bits to 01. If any trap occurs in S-mode, and we
  // fallback to M-mode using the MRET instruction, then in M-mode, we'll read the MPP bits and
  // know that we fell back from S-mode.
  #[inline]
  pub unsafe fn setMppBitsToSMode(&self) {
    self.clearMppBits();
    asm!("csrs mstatus, {}", in(reg)BitMasks::MSTATUS_MPP_SUPERVISOR as usize);
  }
}

// When a trap is taken into M-mode, the mepc (Machine Exception Program counter) register is
// written with the virtual address of the instruction that was interrupted or that encountered the
// exception.
// REFER : section 3.1.14 in privileged ISA manual.
pub struct Mepc;

impl Mepc {
  #[inline]
  pub unsafe fn set(&self, address: usize) {
    asm!("csrw mepc, {}", in(reg)address);
  }
}

// The satp (Supervisor Address Translation and Protection) registers controls supervisor-mode
// address translation and protection.
// REFER : section 10.1.11 in privileged ISA manual.
pub struct Satp;

impl Satp {
  #[inline]
  pub unsafe fn disablePaging(&self) {
    asm!("csrw satp, {}", in(reg)0);
  }
}

/*
  By default, all traps at any privilege level are handled in machine mode, though a machine-mode
  handler can redirect traps back to the appropriate level with the MRET instruction.
  To increase performance, implementations can provide individual read/write bits within medeleg (
  Machine Trap Delegation) and mideleg (Machine Interrupt Delegation) registers to indicate that
  certain exceptions and interrupts should be processed directly by a lower privilege level.

  NOTE : Traps never transition from a more-privileged mode to a less-privileged mode.
*/
// REFER : section 3.1.8 in privileged ISA manual.
pub struct Medeleg;

impl Medeleg {
  #[inline]
  pub unsafe fn delegateExceptionsToSMode(&self) {
    asm!("csrw medeleg, {}", in(reg)0xffff);
  }
}

pub struct Mideleg;

impl Mideleg {
  #[inline]
  pub unsafe fn delegateInterruptsToSMode(&self) {
    asm!("csrw mideleg, {}", in(reg)0xffff);
  }
}

/*
  The SIE (Supervisor Interrupt Enable) register contains bits using which we can enable / disable
  interrupts.

  An interrupt (i) will trap to S-mode if both of the following are true :

    (a) either the current privilege mode is S and the SIE bit in the sstatus register is set, or
        the current privilege mode has less privilege than S-mode.

    (b) bit i is set in both sip and sie.

  NOTE : There are 3 types of interrupts : external (generated by external devices like the UART
  driver), software (generated by software running on the hart) and timer.
*/
// REFER : section 10.1.3 in privileged ISA manual.
pub struct Sie;

impl Sie {
  #[inline]
  pub unsafe fn enableInterrupts(&self) {
    asm!(
      "csrs sie, {}",
      in(reg)BitMasks::SUPERVISOR_EXTERNAL_INTERRUPTS_ENABLE_MASK as usize | BitMasks::SUPERVISOR_TIMER_INTERRUPTS_ENABLE_MASK as usize | BitMasks::SUPERVISOR_SOFTWARE_INTERRUPTS_ENABLE_MASK as usize
    );
  }
}

/*
  To support secure processing and contain faults, it is desirable to limit the physical addresses
  accessible by software running on a hart. An optional Physical Memory Protection (PMP) unit
  provides per-hart machine-mode control registers to allow physical memory access privileges
  (read, write, execute) to be specified for each physical memory region.

  The granularity of PMP access control settings are platform-specific, but the standard PMP
  encoding supports regions as small as four bytes.

  PMP checks are applied to all accesses whose effective privilege mode is S or U, including
  instruction fetches and data accesses in S and U mode, and data accesses in M-mode when the MPRV
  bit in mstatus is set and the MPP field in mstatus contains S or U. PMP checks are also applied
  to page-table accesses for virtual-address translation, for which the effective privilege mode is
  S. Optionally, PMP checks may additionally apply to M-mode accesses, in which case the PMP
  registers themselves are locked, so that even M-mode software cannot change them until the hart
  is reset.

  In effect, PMP can grant permissions to S and U modes, which by default have none, and can revoke
  permissions from M-mode, which by default has full permissions.
*/
pub struct Pmpaddr0;

impl Pmpaddr0 {}
