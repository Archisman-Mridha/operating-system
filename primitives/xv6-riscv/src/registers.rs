use core::arch::asm;

// NOTE : WARL = Write Any Read Legal

#[allow(non_camel_case_types)]
enum BitMasks {
  MSTATUS_MPP_CLEARER = 3 << 11,
  MSTATUS_MPP_SUPERVISOR = 1 << 11,

  SUPERVISOR_SOFTWARE_INTERRUPTS_ENABLE = 1 << 1,
  SUPERVISOR_TIMER_INTERRUPTS_ENABLE = 1 << 5,
  SUPERVISOR_EXTERNAL_INTERRUPTS_ENABLE = 1 << 9,
}

// The mstatus (Machine Status) register keeps track of and controls the hart's current operating
// state.
// REFER : section 3.1.6 in privileged ISA manual.
pub struct Mstatus;

impl Mstatus {
  // NOTE : xPP (x = current privilege mode) bits represent the previous privilege mode.

  // Clears the MPP bits.
  #[inline]
  unsafe fn clearMppBits(&self) {
    asm!("csrc mstatus, {}", in(reg)BitMasks::MSTATUS_MPP_CLEARER as usize);
  }

  // Before switching to S-mode, we'll set the MPP bits to 01. If any trap occurs in S-mode, and we
  // fallback to M-mode using the MRET instruction, then in M-mode, we'll read the MPP bits and
  // know that we fell back from S-mode.
  #[inline]
  pub unsafe fn setMppBitsToSMode(&self) {
    self.clearMppBits();
    asm!("csrs mstatus, {}", in(reg)BitMasks::MSTATUS_MPP_SUPERVISOR as usize);
  }
}

// When a trap is taken into M-mode, the mepc (Machine Exception Program counter) register is
// written with the virtual address of the instruction that was interrupted or that encountered the
// exception.
// REFER : section 3.1.14 in privileged ISA manual.
pub struct Mepc;

impl Mepc {
  #[inline]
  pub unsafe fn set(&self, address: usize) {
    asm!("csrw mepc, {}", in(reg)address);
  }
}

// The satp (Supervisor Address Translation and Protection) registers controls supervisor-mode
// address translation and protection.
// REFER : section 10.1.11 in privileged ISA manual.
pub struct Satp;

impl Satp {
  #[inline]
  pub unsafe fn disablePaging(&self) {
    asm!("csrw satp, {}", in(reg)0);
  }
}

/*
  By default, all traps at any privilege level are handled in machine mode, though a machine-mode
  handler can redirect traps back to the appropriate level with the MRET instruction.
  To increase performance, implementations can provide individual read/write bits within medeleg (
  Machine Trap Delegation) and mideleg (Machine Interrupt Delegation) registers to indicate that
  certain exceptions and interrupts should be processed directly by a lower privilege level.

  NOTE : Traps never transition from a more-privileged mode to a less-privileged mode.
*/
// REFER : section 3.1.8 in privileged ISA manual.
pub struct Medeleg;

impl Medeleg {
  #[inline]
  pub unsafe fn delegateExceptionsToSMode(&self) {
    asm!("csrw medeleg, {}", in(reg)0xffff);
  }
}

pub struct Mideleg;

impl Mideleg {
  #[inline]
  pub unsafe fn delegateInterruptsToSMode(&self) {
    asm!("csrw mideleg, {}", in(reg)0xffff);
  }
}

/*
  The sie (Supervisor Interrupt Enable) register contains bits using which we can enable / disable
  interrupts.

  An interrupt (i) will trap to S-mode if both of the following are true :

    (a) either the current privilege mode is S and the SIE bit in the sstatus register is set, or
        the current privilege mode has less privilege than S-mode.

    (b) bit i is set in both sip and sie.

  NOTE : There are 3 types of interrupts : external (generated by external devices like the UART
  driver), software (generated by software running on the hart) and timer.
*/
// REFER : section 10.1.3 in privileged ISA manual.
pub struct Sie;

impl Sie {
  #[inline]
  pub unsafe fn enableInterrupts(&self) {
    asm!(
      "csrs sie, {}",
      in(reg)BitMasks::SUPERVISOR_EXTERNAL_INTERRUPTS_ENABLE as usize | BitMasks::SUPERVISOR_TIMER_INTERRUPTS_ENABLE as usize | BitMasks::SUPERVISOR_SOFTWARE_INTERRUPTS_ENABLE as usize
    );
  }
}

// REFER : section 3.7 in privileged ISA manual and https://youtu.be/cWlEKpCtjes.
pub mod pmp {
  use core::arch::asm;

  // The A field in a PMP entryâ€™s configuration register encodes the address-matching mode of the
  // associated PMP address register.
  pub enum AddressMatchingMode {
    OFF = 0b00,

    // TOR (Top Of Range) : The associated address register forms the top of the address
    // range, and the preceding PMP address register forms the bottom of the address range.
    TOR = 0b01,

    NA4 = 0b10, // Naturally Aligned 4-byte Region.

    // NAPOT (Naturally Aligned Power-Of-Two Region) makes use of the low-order bits of the
    // associated pmpaddr register to encode the size of the range.
    NAPOT = 0b11,
  }

  pub enum PermissionLevel {
    NONE = 0b000,
    R = 0b001,
    W = 0b010,
    RW = 0b011,
    X = 0b100,
    RX = 0b101,
    WX = 0b110,
    RWX = 0b111,
  }

  pub struct PmpCfg0;

  impl PmpCfg0 {
    pub unsafe fn setPmpaddrConfig(
      &self,
      index: usize,
      addressMatchingMode: AddressMatchingMode,
      permissionLevel: PermissionLevel,
      isLocked: bool,
    ) {
      assert!(index < 8);

      let PmpaddrConfigBitMask =
        (isLocked as usize) << 7 | (addressMatchingMode as usize) << 3 | (permissionLevel as usize);

      unimplemented!();
    }
  }

  pub struct Pmpaddr0;

  impl Pmpaddr0 {
    #[inline]
    pub unsafe fn defineMemoryRegion(&self, memoryAddress: usize) {
      asm!("csrw pmpaddr0, {}", in(reg)memoryAddress);
    }

    pub unsafe fn defineFullPhysicalMemoryRegion(&self) {
      Self.defineMemoryRegion(0x3fffffffffffff);
    }
  }
}

// The mhartid register is a read-only register containing the integer ID of the hardware thread
// running the code.
pub struct Mhartid;

impl Mhartid {
  #[inline]
  pub unsafe fn read(&self) -> usize {
    let hartId: usize;
    asm!("csrr {}, mhartid", out(reg)hartId);
    hartId
  }
}

// The tp (Thread Pointer) register stores the id of the hardware thread on which we're currently
// running.
// Before switching to U-mode, the Kernel saves the value of this register in the stack. On return
// from the U-mode, that value is restored back.
pub struct Tp;

impl Tp {
  #[inline]
  pub unsafe fn write(&self, hartId: usize) {
    asm!("mv tp, {}", in(reg)hartId);
  }
}
