use core::arch::asm;

// NOTE : WARL = Write Any Read Legal

#[allow(non_camel_case_types)]
enum BitMasks {
  MSTATUS_MPP_CLEARER = 3 << 11,
  MSTATUS_MPP_SUPERVISOR = 1 << 11,

  SUPERVISOR_SOFTWARE_INTERRUPTS_ENABLE = 1 << 1,
  SUPERVISOR_TIMER_INTERRUPTS_ENABLE = 1 << 5,
  SUPERVISOR_EXTERNAL_INTERRUPTS_ENABLE = 1 << 9,
}

// The mstatus (Machine Status) register keeps track of and controls the hart's current operating
// state.
// REFER : section 3.1.6 in privileged ISA manual.
pub struct Mstatus;

impl Mstatus {
  // NOTE : xPP (x = current privilege mode) bits represent the previous privilege mode.

  // Clears the MPP bits.
  #[inline]
  unsafe fn clearMppBits(&self) {
    asm!("csrc mstatus, {}", in(reg)BitMasks::MSTATUS_MPP_CLEARER as usize);
  }

  // Before switching to S-mode, we'll set the MPP bits to 01. If any trap occurs in S-mode, and we
  // fallback to M-mode using the MRET instruction, then in M-mode, we'll read the MPP bits and
  // know that we fell back from S-mode.
  #[inline]
  pub unsafe fn setMppBitsToSMode(&self) {
    self.clearMppBits();
    asm!("csrs mstatus, {}", in(reg)BitMasks::MSTATUS_MPP_SUPERVISOR as usize);
  }
}

// When a trap is taken into M-mode, the mepc (Machine Exception Program counter) register is
// written with the virtual address of the instruction that was interrupted or that encountered the
// exception.
// REFER : section 3.1.14 in privileged ISA manual.
pub struct Mepc;

impl Mepc {
  #[inline]
  pub unsafe fn set(&self, address: usize) {
    asm!("csrw mepc, {}", in(reg)address);
  }
}

// The satp (Supervisor Address Translation and Protection) registers controls supervisor-mode
// address translation and protection.
// REFER : section 10.1.11 in privileged ISA manual.
pub struct Satp;

impl Satp {
  #[inline]
  pub unsafe fn disablePaging(&self) {
    asm!("csrw satp, {}", in(reg)0);
  }
}

/*
  By default, all traps at any privilege level are handled in machine mode, though a machine-mode
  handler can redirect traps back to the appropriate level with the MRET instruction.
  To increase performance, implementations can provide individual read/write bits within medeleg (
  Machine Trap Delegation) and mideleg (Machine Interrupt Delegation) registers to indicate that
  certain exceptions and interrupts should be processed directly by a lower privilege level.

  NOTE : Traps never transition from a more-privileged mode to a less-privileged mode.
*/
// REFER : section 3.1.8 in privileged ISA manual.
pub struct Medeleg;

impl Medeleg {
  #[inline]
  pub unsafe fn delegateExceptionsToSMode(&self) {
    asm!("csrw medeleg, {}", in(reg)0xffff);
  }
}

pub struct Mideleg;

impl Mideleg {
  #[inline]
  pub unsafe fn delegateInterruptsToSMode(&self) {
    asm!("csrw mideleg, {}", in(reg)0xffff);
  }
}

/*
  The sie (Supervisor Interrupt Enable) register contains bits using which we can enable / disable
  interrupts.

  An interrupt (i) will trap to S-mode if both of the following are true :

    (a) either the current privilege mode is S and the SIE bit in the sstatus register is set, or
        the current privilege mode has less privilege than S-mode.

    (b) bit i is set in both sip and sie.

  NOTE : There are 3 types of interrupts : external (generated by external devices like the UART
  driver), software (generated by software running on the hart) and timer.
*/
// REFER : section 10.1.3 in privileged ISA manual.
pub struct Sie;

impl Sie {
  #[inline]
  pub unsafe fn enableInterrupts(&self) {
    asm!(
      "csrs sie, {}",
      in(reg)BitMasks::SUPERVISOR_EXTERNAL_INTERRUPTS_ENABLE as usize | BitMasks::SUPERVISOR_TIMER_INTERRUPTS_ENABLE as usize | BitMasks::SUPERVISOR_SOFTWARE_INTERRUPTS_ENABLE as usize
    );
  }
}

pub mod pmp {
  /*
    Physical Memory Protection (PMP) :

    The Physical Memory Protection (PMP) unit provides per-hart machine-mode control registers to
    allow physical memory access privileges (read, write, execute) to be specified for each physical
    memory region.

    The granularity of PMP access control settings are platform-specific, but the standard PMP
    encoding supports regions as small as four bytes.

    PMP checks are applied to all accesses whose effective privilege mode is S or U, including
    instruction fetches and data accesses in S and U mode, and data accesses in M-mode when the MPRV
    bit in mstatus is set and the MPP field in mstatus contains S or U. PMP checks are also applied
    to page-table accesses for virtual-address translation, for which the effective privilege mode is
    S.

    PMP CSRs :

    PMP entries are described by an 8-bit configuration register and one MXLEN-bit address register.
    Up to 64 PMP entries are supported.

    (1) PMP configuration registers are densely packed into CSRs to minimize context-switch time. For
        RV64, eight even-numbered CSRs (pmpcfg0, pmpcfg2, …, pmpcfg14) hold the configurations for
        the 64 PMP entries. PMP CSRs are only accessible to M-mode.

    (2) The PMP address registers are CSRs named pmpaddr0-pmpaddr63. For RV64, each PMP address
        register encodes bits 55-2 of a 56-bit physical address.

    REFER : section 3.7 in privileged ISA manual and https://youtu.be/cWlEKpCtjes.
  */

  use core::arch::asm;

  /*
    A PMP configuration register contains the following bits (from right to left) :

    (1) The R, W, and X bits when set, indicate that the PMP entry permits read, write, and
        instruction execution, respectively. When one of these bits is clear, the corresponding access
        type is denied.

        NOTE : Attempting to fetch an instruction from a PMP region that does not have execute
        permissions raises an instruction access-fault exception.

    (2) The A field encodes the address-matching mode of the associated PMP address register.

    (3) The L bit indicates that the PMP entry is locked, i.e., writes to the configuration register
        and associated address registers are ignored. Locked PMP entries remain locked until the hart
        is reset.
        In addition to locking the PMP entry, the L bit indicates whether the R/W/X permissions are
        enforced on M-mode accesses. When the L bit is set, these permissions are enforced for all
        privilege modes. When the L bit is clear, any M-mode access matching the PMP entry will
        succeed; the R/W/X permissions apply only to S and U modes.
  */
  pub struct PmpCfg0;

  #[allow(unused)]
  pub enum PermissionLevel {
    NONE = 0b000,
    R = 0b001,
    W = 0b010,
    RW = 0b011,
    X = 0b100,
    RX = 0b101,
    WX = 0b110,
    RWX = 0b111,
  }

  // The A field in a PMP entry’s configuration register encodes the address-matching mode of the
  // associated PMP address register.
  #[allow(unused)]
  pub enum AddressMatchingMode {
    OFF = 0b00,

    // TOR (Top Of Range) : The associated address register forms the top of the address range, and
    // the preceding PMP address register forms the bottom of the address range.
    TOR = 0b01,

    NA4 = 0b10, // Naturally Aligned 4-byte Region.

    // NAPOT (Naturally Aligned Power-Of-Two Region) makes use of the low-order bits of the associated
    // pmpaddr register to encode the size of the range.
    NAPOT = 0b11,
  }

  impl PmpCfg0 {
    // Sets bits of the PMP configuration register (which corresponds to some pmpaddr register) in the
    // pmpcfg0 CSR.
    pub unsafe fn setPmpaddrConfig(
      &self,
      index: usize, // (of the PMP configuration register in the pmpcfg0 CSR).
      addressMatchingMode: AddressMatchingMode,
      permissionLevel: PermissionLevel,
      isLocked: bool,
    ) {
      assert!(index < 8);

      self.clearPmpConfigurationRegisterBits(index);

      let pmpaddrConfigBitMask =
        (isLocked as usize) << 7 | (addressMatchingMode as usize) << 3 | (permissionLevel as usize);

      let pmpcfgBitMask = pmpaddrConfigBitMask << (index * 8);

      asm!("csrs pmpcfg0, {}", in(reg)pmpcfgBitMask);
    }

    // Clears bits of a PMP configuration register in the pmpcfg0 CSR.
    unsafe fn clearPmpConfigurationRegisterBits(
      &self,
      index: usize, // (of the PMP configuration register in the pmpcfg0 CSR).
    ) {
      let bitMask = 0xff << (index * 8);
      asm!("csrc pmpcfg0, {}", in(reg)bitMask as usize);
    }
  }

  pub struct Pmpaddr0;

  impl Pmpaddr0 {
    #[inline]
    pub unsafe fn defineMemoryRegion(&self, memoryAddress: usize) {
      asm!("csrw pmpaddr0, {}", in(reg)memoryAddress);
    }

    pub unsafe fn defineFullPhysicalMemoryAsRegion(&self) {
      Self.defineMemoryRegion(0x3fffffffffffff);
    }
  }
}

// The mhartid register is a read-only register containing the integer ID of the hardware thread
// running the code.
pub struct Mhartid;

impl Mhartid {
  #[inline]
  pub unsafe fn read(&self) -> usize {
    let hartId: usize;
    asm!("csrr {}, mhartid", out(reg)hartId);
    hartId
  }
}

// The tp (Thread Pointer) register stores the id of the hardware thread on which we're currently
// running.
// Before switching to U-mode, the Kernel saves the value of this register in the stack. On return
// from the U-mode, that value is restored back.
pub struct Tp;

impl Tp {
  #[inline]
  pub unsafe fn write(&self, hartId: usize) {
    asm!("mv tp, {}", in(reg)hartId);
  }
}
